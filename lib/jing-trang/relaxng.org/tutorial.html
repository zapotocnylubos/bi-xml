<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>RELAX NG Tutorial</title><link rel="stylesheet" href="tr.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.40"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><p class="logo"><a href="http://www.oasis-open.org/"><img src="oasis.png" alt="OASIS" border="0"></a></p><div><h1 class="title"><a name="IDAHAYR"></a>RELAX NG Tutorial</h1></div><div><h2>Committee Specification 3 December 2001</h2></div><div><dl><dt>This version:</dt><dd>Committee Specification: 3 December 2001</dd></dl><dl><dt>Previous versions:</dt><dd>Committee Specification: 10 August 2001</dd></dl></div><div><dl><dt>Editors:</dt><dd>James Clark <tt>&lt;<a href="mailto:jjc@jclark.com">jjc@jclark.com</a>&gt;</tt>, MURATA Makoto <tt>&lt;<a href="mailto:EB2M-MRT@asahi-net.or.jp">EB2M-MRT@asahi-net.or.jp</a>&gt;</tt></dd></dl></div><div></div><div><div class="legalnotice"><p>Copyright © The Organization for the Advancement of
Structured Information Standards [OASIS] 2001. All Rights
Reserved.</p><p>This document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defined in the OASIS Intellectual Property
Rights document must be followed, or as required to translate it into
languages other than English.</p><p>The limited permissions granted above are perpetual and will not
be revoked by OASIS or its successors or assigns.</p><p>This document and the information contained herein is provided
on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p></div></div><div><hr><div class="abstract"><h2><a name="IDAMCYR"></a>Abstract</h2><p>RELAX NG is a simple schema language for XML, based on <a href="#relax" title="[RELAX]">[RELAX]</a> and <a href="#trex" title="[TREX]">[TREX]</a>. A RELAX NG schema
specifies a pattern for the structure and content of an XML
document. A RELAX NG schema thus identifies a class of XML documents
consisting of those documents that match the pattern.  A RELAX NG
schema is itself an XML document.</p><p>This document is a tutorial for RELAX NG version 1.0.</p></div></div><div><div class="legalnotice"><h2>Status of this Document</h2><p>This Committee Specification was approved for publication by the
OASIS RELAX NG technical committee.  It is a stable document which
represents the consensus of the committee.  Comments on this document
may be sent to <a href="mailto:relax-ng-comment@lists.oasis-open.org" target="_top">relax-ng-comment@lists.oasis-open.org</a>.</p><p>A list of known errors in this document is available at <a href="http://www.oasis-open.org/committees/relax-ng/tutorial-20011203-errata.html" target="_top">http://www.oasis-open.org/committees/relax-ng/tutorial-20011203-errata.html</a>.</p></div></div></div><div class="toc"><h2>Table of Contents</h2><dl><dt>1 <a href="#IDAHDYR">Getting started</a></dt><dt>2 <a href="#IDA5EYR">Choice</a></dt><dt>3 <a href="#IDA0FYR">Attributes</a></dt><dt>4 <a href="#IDAETYR">Named patterns</a></dt><dt>5 <a href="#IDA5UYR">Datatyping</a></dt><dt>6 <a href="#IDAVXYR">Enumerations</a></dt><dt>7 <a href="#IDAK0YR">Lists</a></dt><dt>8 <a href="#IDAN1YR">Interleaving</a></dt><dt>9 <a href="#IDAX4YR">Modularity</a></dt><dd><dl><dt>9.1 <a href="#IDA04YR">Referencing external patterns</a></dt><dt>9.2 <a href="#IDACAZR">Combining definitions</a></dt><dt>9.3 <a href="#IDAXBZR">Merging grammars</a></dt><dt>9.4 <a href="#IDAVEZR">Replacing definitions</a></dt></dl></dd><dt>10 <a href="#IDADGZR">Namespaces</a></dt><dd><dl><dt>10.1 <a href="#IDAIGZR">Using the <tt>ns</tt> attribute</a></dt><dt>10.2 <a href="#IDAYJZR">Qualified names</a></dt></dl></dd><dt>11 <a href="#IDAFLZR">Name classes</a></dt><dt>12 <a href="#IDA1OZR">Annotations</a></dt><dt>13 <a href="#IDA3PZR">Nested grammars</a></dt><dt>14 <a href="#IDAIRZR">Non-restrictions</a></dt><dt>15 <a href="#IDA3RZR">Further information</a></dt></dl><h3>Appendixes</h3><dl><dt>A <a href="#IDAGSZR">Comparison with XML DTDs</a></dt><dt>B <a href="#IDAZTZR">Comparison with RELAX Core</a></dt><dd><dl><dt>B.1 <a href="#IDA4TZR">Mapping RELAX NG to RELAX Core</a></dt><dd><dl><dt>B.1.1 <a href="#IDABUZR"><tt>elementRule</tt>-<tt>tag</tt> pairs</a></dt><dt>B.1.2 <a href="#IDAJVZR"><tt>hedgeRule</tt></a></dt><dt>B.1.3 <a href="#IDACWZR"><tt>attPool</tt></a></dt><dt>B.1.4 <a href="#IDAVWZR">Hedge models</a></dt><dt>B.1.5 <a href="#IDAKYZR">Attribute declarations</a></dt></dl></dd><dt>B.2 <a href="#IDALZZR">Examples</a></dt><dd><dl><dt>B.2.1 <a href="#IDAOZZR">Ancestor-and-sibling-sensitive content models</a></dt><dt>B.2.2 <a href="#IDAC0ZR">Attribute-sensitive content model</a></dt></dl></dd><dt>B.3 <a href="#IDA10ZR">Features of RELAX NG beyond RELAX Core</a></dt></dl></dd><dt>C <a href="#IDAS2ZR">Comparison with TREX</a></dt><dt>D <a href="#IDA3A0R">Changes from 12 June 2001 version</a></dt><dt><a href="#IDACC0R">References</a></dt></dl></div><hr><div class="section"><a name="IDAHDYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAHDYR"></a>1. Getting started</h2></div></div><p>Consider a simple XML representation of an email address book:</p><pre class="programlisting">&lt;addressBook&gt;
  &lt;card&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</pre><p>The DTD would be as follows:</p><pre class="programlisting">&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)&gt;
&lt;!ELEMENT card (name, email)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT email (#PCDATA)&gt;
]&gt;</pre><p>A RELAX NG pattern for this could be written as follows:</p><pre class="programlisting">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>If the <tt>addressBook</tt> is required to be non-empty, then
we can use <tt>oneOrMore</tt> instead of
<tt>zeroOrMore</tt>:</p><pre class="programlisting">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;oneOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/oneOrMore&gt;
&lt;/element&gt;</pre><p>Now let's change it to allow each <tt>card</tt> to have an
optional <tt>note</tt> element:</p><pre class="programlisting">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;optional&gt;
	&lt;element name="note"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>Note that the <tt>text</tt> pattern matches arbitrary text,
including empty text. Note also that whitespace separating tags is
ignored when matching against a pattern.</p><p>All the elements specifying the pattern must be namespace qualified
by the namespace URI:</p><pre class="programlisting">http://relaxng.org/ns/structure/1.0</pre><p>The examples above use a default namespace declaration
<tt>xmlns="http://relaxng.org/ns/structure/1.0"</tt> for this. A
namespace prefix is equally acceptable:</p><pre class="programlisting">&lt;rng:element name="addressBook" xmlns:rng="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;rng:zeroOrMore&gt;
    &lt;rng:element name="card"&gt;
      &lt;rng:element name="name"&gt;
        &lt;rng:text/&gt;
      &lt;/rng:element&gt;
      &lt;rng:element name="email"&gt;
        &lt;rng:text/&gt;
      &lt;/rng:element&gt;
    &lt;/rng:element&gt;
  &lt;/rng:zeroOrMore&gt;
&lt;/rng:element&gt;</pre><p>For the remainder of this document, the default namespace
declaration will be left out of examples.</p></div><div class="section"><a name="IDA5EYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA5EYR"></a>2. Choice</h2></div></div><p>Now suppose we want to allow the <tt>name</tt> to be broken
down into a <tt>givenName</tt> and a <tt>familyName</tt>,
allowing an <tt>addressBook</tt> like this:</p><pre class="programlisting">&lt;addressBook&gt;
  &lt;card&gt;
    &lt;givenName&gt;John&lt;/givenName&gt;
    &lt;familyName&gt;Smith&lt;/familyName&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</pre><p>We can use the following pattern:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;choice&gt;
        &lt;element name="name"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
        &lt;group&gt;
          &lt;element name="givenName"&gt;
            &lt;text/&gt;
          &lt;/element&gt;
          &lt;element name="familyName"&gt;
            &lt;text/&gt;
          &lt;/element&gt;
        &lt;/group&gt;
      &lt;/choice&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;optional&gt;
	&lt;element name="note"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>This corresponds to the following DTD:</p><pre class="programlisting">&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)&gt;
&lt;!ELEMENT card ((name | (givenName, familyName)), email, note?)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT email (#PCDATA)&gt;
&lt;!ELEMENT givenName (#PCDATA)&gt;
&lt;!ELEMENT familyName (#PCDATA)&gt;
&lt;!ELEMENT note (#PCDATA)&gt;
]&gt;</pre></div><div class="section"><a name="IDA0FYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA0FYR"></a>3. Attributes</h2></div></div><p>Suppose we want the <tt>card</tt> element to have attributes
rather than child elements. The DTD might look like this:</p><pre class="programlisting">&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)&gt;
&lt;!ELEMENT card EMPTY&gt;
&lt;!ATTLIST card
  name CDATA #REQUIRED
  email CDATA #REQUIRED&gt;
]&gt;</pre><p>Just change each <tt>element</tt> pattern to an
<tt>attribute</tt> pattern:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>In XML, the order of attributes is traditionally not significant.
RELAX NG follows this tradition.  The above pattern would match both</p><pre class="programlisting">&lt;card name="John Smith" email="js@example.com"/&gt;</pre><p>and</p><pre class="programlisting">&lt;card email="js@example.com" name="John Smith"/&gt;</pre><p>In contrast, the order of elements is significant. The pattern</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;element name="name"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
  &lt;element name="email"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre><p>would <i>not</i> match</p><pre class="programlisting">&lt;card&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;/card&gt;</pre><p>Note that an <tt>attribute</tt> element by itself indicates a
required attribute, just as an <tt>element</tt> element by itself
indicates a required element. To specify an optional attribute, use
<tt>optional</tt> just as with <tt>element</tt>:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
      &lt;optional&gt;
        &lt;attribute name="note"&gt;
          &lt;text/&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>The <tt>group</tt> and <tt>choice</tt> patterns can be
applied to <tt>attribute</tt> patterns in the same way they are
applied to <tt>element</tt> patterns.  For example, if we wanted
to allow either a <tt>name</tt> attribute or both a
<tt>givenName</tt> and a <tt>familyName</tt> attribute, we can
specify this in the same way that we would if we were using
elements:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;choice&gt;
        &lt;attribute name="name"&gt;
          &lt;text/&gt;
        &lt;/attribute&gt;
        &lt;group&gt;
          &lt;attribute name="givenName"&gt;
            &lt;text/&gt;
          &lt;/attribute&gt;
          &lt;attribute name="familyName"&gt;
            &lt;text/&gt;
          &lt;/attribute&gt;
        &lt;/group&gt;
      &lt;/choice&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>The <tt>group</tt> and <tt>choice</tt>
patterns can combine <tt>element</tt> and
<tt>attribute</tt> patterns without restriction. For
example, the following pattern would allow a choice of elements and
attributes independently for both the <tt>name</tt> and the
<tt>email</tt> part of a <tt>card</tt>:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;choice&gt;
	&lt;element name="name"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
	&lt;attribute name="name"&gt;
	  &lt;text/&gt;
	&lt;/attribute&gt;
      &lt;/choice&gt;
      &lt;choice&gt;
	&lt;element name="email"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
	&lt;attribute name="email"&gt;
	  &lt;text/&gt;
	&lt;/attribute&gt;
      &lt;/choice&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>As usual, the relative order of elements is significant, but the
relative order of attributes is not. Thus the above would match any
of:</p><pre class="programlisting">&lt;card name="John Smith" email="js@example.com"/&gt;
&lt;card email="js@example.com" name="John Smith"/&gt;
&lt;card email="js@example.com"&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;/card&gt;
&lt;card name="John Smith"&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;/card&gt;
&lt;card&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;/card&gt;</pre><p>However, it would not match</p><pre class="programlisting">&lt;card&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;/card&gt;</pre><p>because the pattern for <tt>card</tt> requires any
<tt>email</tt> child element to follow any <tt>name</tt> child
element.</p><p>There is one difference between <tt>attribute</tt> and
<tt>element</tt> patterns: <tt>&lt;text/&gt;</tt>
is the default for the content of an <tt>attribute</tt> pattern,
whereas an <tt>element</tt> pattern is not allowed to be
empty. For example,</p><pre class="programlisting">&lt;attribute name="email"/&gt;</pre><p>is short for</p><pre class="programlisting">&lt;attribute name="email"&gt;
  &lt;text/&gt;
&lt;/attribute&gt;</pre><p>It might seem natural that</p><pre class="programlisting">&lt;element name="x"/&gt;</pre><p>matched an <tt>x</tt> element with no attributes and no
content.  However, this would make the meaning of empty content
inconsistent between the <tt>element</tt> pattern and the
<tt>attribute</tt> pattern, so RELAX NG does not allow the
<tt>element</tt> pattern to be empty. A pattern that matches an
element with no attributes and no children must use
<tt>&lt;empty/&gt;</tt> explicitly:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;optional&gt;
        &lt;element name="prefersHTML"&gt;
          &lt;empty/&gt;
        &lt;/element&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>Even if the pattern in an <tt>element</tt> pattern
matches attributes only, there is no need to use
<tt>empty</tt>. For example,</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;attribute name="email"&gt;
    &lt;text/&gt;
  &lt;/attribute&gt;
&lt;/element&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;attribute name="email"&gt;
    &lt;text/&gt;
  &lt;/attribute&gt;
  &lt;empty/&gt;
&lt;/element&gt;</pre></div><div class="section"><a name="IDAETYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAETYR"></a>4. Named patterns</h2></div></div><p>For a non-trivial RELAX NG pattern, it is often convenient to be able
to give names to parts of the pattern.  Instead of</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
	&lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>we can write</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="cardContent"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="cardContent"&gt;
    &lt;element name="name"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
    &lt;element name="email"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>A <tt>grammar</tt> element has a single <tt>start</tt>
child element, and zero or more <tt>define</tt> child elements.
The <tt>start</tt> and <tt>define</tt> elements contain
patterns. These patterns can contain <tt>ref</tt> elements that
refer to patterns defined by any of the <tt>define</tt> elements
in that <tt>grammar</tt> element. A <tt>grammar</tt> pattern
is matched by matching the pattern contained in the <tt>start</tt>
element.</p><p>We can use the <tt>grammar</tt> element to write patterns in a
style similar to DTDs:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;ref name="AddressBook"/&gt;
  &lt;/start&gt;

  &lt;define name="AddressBook"&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="Card"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="Card"&gt;
    &lt;element name="card"&gt;
      &lt;ref name="Name"/&gt;
      &lt;ref name="Email"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="Name"&gt;
    &lt;element name="name"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="Email"&gt;
    &lt;element name="email"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>Recursive references are allowed.  For example,</p><pre class="programlisting">&lt;define name="inline"&gt;
  &lt;zeroOrMore&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="bold"&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="italic"&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="span"&gt;
        &lt;optional&gt;
          &lt;attribute name="style"/&gt;
        &lt;/optional&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;</pre><p>However, recursive references must be within an
<tt>element</tt>.  Thus, the following is <i>not</i>
allowed:</p><pre class="programlisting">&lt;define name="inline"&gt;
  &lt;choice&gt;
    &lt;text/&gt;
    &lt;element name="bold"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
    &lt;element name="italic"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
    &lt;element name="span"&gt;
      &lt;optional&gt;
	&lt;attribute name="style"/&gt;
      &lt;/optional&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
  &lt;/choice&gt;
  &lt;optional&gt;
    &lt;ref name="inline"/&gt;
  &lt;/optional&gt;
&lt;/define&gt;</pre></div><div class="section"><a name="IDA5UYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA5UYR"></a>5. Datatyping</h2></div></div><p>RELAX NG allows patterns to reference externally-defined
datatypes, such as those defined by <a href="#xmlschema-2" title="[W3C XML Schema Datatypes]">[W3C XML Schema Datatypes]</a>.  RELAX NG
implementations may differ in what datatypes they support.  You must
use datatypes that are supported by the implementation you plan to
use.</p><p>The <tt>data</tt> pattern matches a string that
represents a value of a named datatype. The
<tt>datatypeLibrary</tt> attribute contains a URI
identifying the library of datatypes being used. The datatype
library defined by <a href="#xmlschema-2" title="[W3C XML Schema Datatypes]">[W3C XML Schema Datatypes]</a> would be identified by the
URI <tt>http://www.w3.org/2001/XMLSchema-datatypes</tt>.
The <tt>type</tt> attribute specifies the name of the
datatype in the library identified by the
<tt>datatypeLibrary</tt> attribute. For example, if a
RELAX NG implementation supported the datatypes of
<a href="#xmlschema-2" title="[W3C XML Schema Datatypes]">[W3C XML Schema Datatypes]</a>, you could use:</p><pre class="programlisting">&lt;element name="number"&gt;
  &lt;data type="integer" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"/&gt;
&lt;/element&gt;</pre><p>It is inconvenient to specify the
<tt>datatypeLibrary</tt> attribute on every
<tt>data</tt> element, so RELAX NG allows the
<tt>datatypeLibrary</tt> attribute to be inherited.  The
<tt>datatypeLibrary</tt> attribute can be specified on any
RELAX NG element.  If a <tt>data</tt> element does not have
a <tt>datatypeLibrary</tt> attribute, it will use the
value from the closest ancestor that has a
<tt>datatypeLibrary</tt> attribute.  Typically, the
<tt>datatypeLibrary</tt> attribute is specified on the
root element of the RELAX NG pattern. For example,</p><pre class="programlisting">&lt;element name="point" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;element name="x"&gt;
    &lt;data type="double"/&gt;
  &lt;/element&gt;
  &lt;element name="y"&gt;
    &lt;data type="double"/&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre><p>If the children of an element or an attribute match a
<tt>data</tt> pattern, then complete content of the element or
attribute must match that <tt>data</tt> pattern.  It is not
permitted to have a pattern which allows part of the content to match
a <tt>data</tt> pattern, and another part to match another
pattern. For example, the following pattern is <i>not</i>
allowed:</p><pre class="programlisting">&lt;element name="bad"&gt;
  &lt;data type="int"/&gt;
  &lt;element name="note"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre><p>However, this would be fine:</p><pre class="programlisting">&lt;element name="ok"&gt;
  &lt;data type="int"/&gt;
  &lt;attribute name="note"&gt;
    &lt;text/&gt;
  &lt;/attribute&gt;
&lt;/element&gt;</pre><p>Note that this restriction does not apply to the
<tt>text</tt> pattern.</p><p>Datatypes may have parameters. For example, a string datatype may
have a parameter controlling the length of the string.  The parameters
applicable to any particular datatype are determined by the datatyping
vocabulary.  Parameters are specified by adding one or more
<tt>param</tt> elements as children of the <tt>data</tt>
element.  For example, the following constrains the <tt>email</tt>
element to contain a string at most 127 characters long:</p><pre class="programlisting">&lt;element name="email"&gt;
  &lt;data type="string"&gt;
    &lt;param name="maxLength"&gt;127&lt;/param&gt;
  &lt;/data&gt;
&lt;/element&gt;</pre></div><div class="section"><a name="IDAVXYR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAVXYR"></a>6. Enumerations</h2></div></div><p>Many markup vocabularies have attributes whose value is constrained
to be one of set of specified values.  The <tt>value</tt> pattern
matches a string that has a specified value.  For example,</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;attribute name="name"/&gt;
  &lt;attribute name="email"/&gt;
  &lt;attribute name="preferredFormat"&gt;
    &lt;choice&gt;
      &lt;value&gt;html&lt;/value&gt;
      &lt;value&gt;text&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/attribute&gt;
&lt;/element&gt;</pre><p>allows the <tt>preferredFormat</tt> attribute to have the value
<tt>html</tt> or <tt>text</tt>.  This corresponds to the
DTD:</p><pre class="programlisting">&lt;!DOCTYPE card [
&lt;!ELEMENT card EMPTY&gt;
&lt;!ATTLIST card
  name CDATA #REQUIRED
  email CDATA #REQUIRED
  preferredFormat (html|text) #REQUIRED&gt;
]&gt;</pre><p>The <tt>value</tt> pattern is not restricted to attribute
values. For example, the following is allowed:</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;element name="name"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
  &lt;element name="email"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
  &lt;element name="preferredFormat"&gt;
    &lt;choice&gt;
      &lt;value&gt;html&lt;/value&gt;
      &lt;value&gt;text&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre><p>The prohibition against a <tt>data</tt> pattern's matching
only part of the content of an element also applies to
<tt>value</tt> patterns.</p><p>By default, the <tt>value</tt> pattern will consider the string
in the pattern to match the string in the document if the two strings
are the same after the whitespace in both strings is normalized.
Whitespace normalization strips leading and trailing whitespace
characters, and collapses sequences of one or more whitespace
characters to a single space character.  This corresponds to the
behaviour of an XML parser for an attribute that is declared as other
than CDATA. Thus the above pattern will match any of:</p><pre class="programlisting">&lt;card name="John Smith" email="js@example.com" preferredFormat="html"/&gt;
&lt;card name="John Smith" email="js@example.com" preferredFormat="  html  "/&gt;</pre><p>The way that the <tt>value</tt> pattern compares the
pattern string with the document string can be controlled by
specifying a <tt>type</tt> attribute and optionally a
<tt>datatypeLibrary</tt> attribute, which identify a
datatype in the same way as for the <tt>data</tt> pattern.
The pattern string matches the document string if they both represent
the same value of the specified datatype. Thus, whereas the
<tt>data</tt> pattern matches an arbitrary value of a
datatype, the <tt>value</tt> pattern matches a specific
value of a datatype.</p><p>If there is no ancestor element with a
<tt>datatypeLibrary</tt> element, the datatype library
defaults to a built-in RELAX NG datatype library.  This provides two
datatypes, <tt>string</tt> and <tt>token</tt>.
The built-in datatype <tt>token</tt> corresponds to the
default comparison behavior of the <tt>value</tt> pattern.
The built-in datatype <tt>string</tt> compares strings
without any whitespace normalization (other than the end-of-line and
attribute value normalization automatically performed by XML).  For
example,</p><pre class="programlisting">&lt;element name="card"&gt;
  &lt;attribute name="name"/&gt;
  &lt;attribute name="email"/&gt;
  &lt;attribute name="preferredFormat"&gt;
    &lt;choice&gt;
      &lt;value type="string"&gt;html&lt;/value&gt;
      &lt;value type="string"&gt;text&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/attribute&gt;
&lt;/element&gt;</pre><p>will <i>not</i> match</p><pre class="programlisting">&lt;card name="John Smith" email="js@example.com" preferredFormat="  html  "/&gt;</pre></div><div class="section"><a name="IDAK0YR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAK0YR"></a>7. Lists</h2></div></div><p>The <tt>list</tt> pattern matches a whitespace-separated
sequence of tokens; it contains a pattern that the sequence of
individual tokens must match.  The <tt>list</tt> pattern
splits a string into a list of strings, and then matches the resulting
list of strings against the pattern inside the <tt>list</tt>
pattern.</p><p>For example, suppose we want to have a <tt>vector</tt>
element that contains two floating point numbers separated by
whitespace.  We could use <tt>list</tt> as follows:</p><pre class="programlisting">&lt;element name="vector"&gt;
  &lt;list&gt;
    &lt;data type="float"/&gt;
    &lt;data type="float"/&gt;
  &lt;/list&gt;
&lt;/element&gt;</pre><p>Or suppose we want the <tt>vector</tt> element to
contain a list of one or more floating point numbers separated by
whitespace:</p><pre class="programlisting">&lt;element name="vector"&gt;
  &lt;list&gt;
    &lt;oneOrMore&gt;
      &lt;data type="double"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/list&gt;
&lt;/element&gt;</pre><p>Or suppose we want a <tt>path</tt> element containing
an even number of floating point numbers:</p><pre class="programlisting">&lt;element name="path"&gt;
  &lt;list&gt;
    &lt;oneOrMore&gt;
      &lt;data type="double"/&gt;
      &lt;data type="double"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/list&gt;
&lt;/element&gt;</pre></div><div class="section"><a name="IDAN1YR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAN1YR"></a>8. Interleaving</h2></div></div><p>The <tt>interleave</tt> pattern allows child elements to occur
in any order. For example, the following would allow the
<tt>card</tt> element to contain the <tt>name</tt> and
<tt>email</tt> elements in any order:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;interleave&gt;
	&lt;element name="name"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
	&lt;element name="email"&gt;
	  &lt;text/&gt;
	&lt;/element&gt;
      &lt;/interleave&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>The pattern is called <tt>interleave</tt> because of how it
works with patterns that match more than one element.  Suppose we want
to write a pattern for the HTML <tt>head</tt> element which
requires exactly one <tt>title</tt> element, at most one
<tt>base</tt> element and zero or more <tt>style</tt>,
<tt>script</tt>, <tt>link</tt> and <tt>meta</tt> elements
and suppose we are writing a <tt>grammar</tt> pattern that has one
definition for each element.  Then we could define the pattern for
<tt>head</tt> as follows:</p><pre class="programlisting">&lt;define name="head"&gt;
  &lt;element name="head"&gt;
    &lt;interleave&gt;
      &lt;ref name="title"/&gt;
      &lt;optional&gt;
        &lt;ref name="base"/&gt;
      &lt;/optional&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="style"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="script"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="link"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="meta"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/interleave&gt;
  &lt;/element&gt;
&lt;/define&gt;</pre><p>Suppose we had a <tt>head</tt> element that contained a
<tt>meta</tt> element, followed by a <tt>title</tt> element,
followed by a <tt>meta</tt> element.  This would match the pattern
because it is an interleaving of a sequence of two <tt>meta</tt>
elements, which match the child pattern</p><pre class="programlisting">      &lt;zeroOrMore&gt;
        &lt;ref name="meta"/&gt;
      &lt;/zeroOrMore&gt;</pre><p>and a sequence of one <tt>title</tt> element, which matches
the child pattern</p><pre class="programlisting">      &lt;ref name="title"/&gt;</pre><p>The semantics of the <tt>interleave</tt> pattern are that a
sequence of elements matches an <tt>interleave</tt> pattern if it
is an interleaving of sequences that match the child patterns of the
<tt>interleave</tt> pattern.  Note that this is different from the
<tt>&amp;</tt> connector in SGML: <tt>A* &amp; B</tt> matches
the sequence of elements <tt>A A B</tt> or the sequence of
elements <tt>B A A</tt> but not the sequence of elements <tt>A B
A</tt>.</p><p>One special case of <tt>interleave</tt> is very common:
interleaving <tt>&lt;text/&gt;</tt> with a pattern
<i><tt>p</tt></i> represents a pattern that matches what <i><tt>p</tt></i>
matches but also allows characters to occur as children.  The
<tt>mixed</tt> element is a shorthand for this.</p><pre class="programlisting">&lt;mixed&gt; <i><tt>p</tt></i> &lt;/mixed&gt;</pre><p>is short for</p><pre class="programlisting">&lt;interleave&gt; &lt;text/&gt; <i><tt>p</tt></i> &lt;/interleave&gt;</pre></div><div class="section"><a name="IDAX4YR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAX4YR"></a>9. Modularity</h2></div></div><div class="section"><a name="IDA04YR"></a><div class="titlepage"><div><h3 class="title"><a name="IDA04YR"></a>9.1. Referencing external patterns</h3></div></div><p>The <tt>externalRef</tt> pattern can be used to
reference a pattern defined in a separate file.  The
<tt>externalRef</tt> element has a required
<tt>href</tt> attribute that specifies the URL of a file
containing the pattern.  The <tt>externalRef</tt> matches if
the pattern contained in the specified URL matches. Suppose for
example, you have a RELAX NG pattern that matches HTML inline content
stored in <tt>inline.rng</tt>:</p><pre class="programlisting">&lt;grammar&gt;
  &lt;start&gt;
    &lt;ref name="inline"/&gt;
  &lt;/start&gt;

  &lt;define name="inline"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        &lt;text/&gt;
        &lt;element name="code"&gt;
          &lt;ref name="inline"/&gt;
        &lt;/element&gt;
        &lt;element name="em"&gt;
          &lt;ref name="inline"/&gt;
        &lt;/element&gt;
        &lt;!-- etc --&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</pre><p>Then we could allow the <tt>note</tt> element to contain
inline HTML markup by using <tt>externalRef</tt> as follows:</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;optional&gt;
	&lt;element name="note"&gt;
	  &lt;externalRef href="inline.rng"/&gt;
	&lt;/element&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>For another example, suppose you have two RELAX NG patterns stored in
files <tt>pattern1.rng</tt> and <tt>pattern2.rng</tt>. Then
the following is a pattern that matches anything matched
by either of those patterns:</p><pre class="programlisting">&lt;choice&gt;
  &lt;externalRef href="pattern1.rng"/&gt;
  &lt;externalRef href="pattern2.rng"/&gt;
&lt;/choice&gt;</pre></div><div class="section"><a name="IDACAZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDACAZR"></a>9.2. Combining definitions</h3></div></div><p>If a grammar contains multiple definitions with the same name,
then the definitions must specify how they are to be combined into a
single definition by using the <tt>combine</tt> attribute.
The <tt>combine</tt> attribute may have the value
<tt>choice</tt> or <tt>interleave</tt>. For
example,</p><pre class="programlisting">&lt;define name="inline.class" combine="choice"&gt;
  &lt;element name="bold"&gt;
    &lt;ref name="inline"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="inline.class" combine="choice"&gt;
  &lt;element name="italic"&gt;
    &lt;ref name="inline"/&gt;
  &lt;/element&gt;
&lt;/define&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;define name="inline.class"&gt;
  &lt;choice&gt;
    &lt;element name="bold"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
    &lt;element name="italic"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
  &lt;/choice&gt;
&lt;/define&gt;</pre><p>When combining attributes, <tt>combine="interleave"</tt>
is typically used.  For example,</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="card.attlist"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist" combine="interleave"&gt;
    &lt;attribute name="name"&gt;
      &lt;text/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name="card.attlist" combine="interleave"&gt;
    &lt;attribute name="email"&gt;
      &lt;text/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="card.attlist"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist"&gt;
    &lt;interleave&gt;
      &lt;attribute name="name"&gt;
	&lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
	&lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>which is equivalent to</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="card.attlist"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist"&gt;
    &lt;group&gt;
      &lt;attribute name="name"&gt;
	&lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
	&lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/group&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>since combining attributes with <tt>interleave</tt>
has the same effect as combining them with
<tt>group</tt>.</p><p>It is an error for two definitions of the same name to specify
different values for <tt>combine</tt>. Note that the order
of definitions within a grammar is not significant.</p><p>Multiple <tt>start</tt> elements can be combined in
the same way as multiple definitions.</p></div><div class="section"><a name="IDAXBZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDAXBZR"></a>9.3. Merging grammars</h3></div></div><p>The <tt>include</tt> element allows grammars to be
merged together. A <tt>grammar</tt> pattern may have
<tt>include</tt> elements as children.  An
<tt>include</tt> element has a required
<tt>href</tt> attribute that specifies the URL of a file
containing a <tt>grammar</tt> pattern.  The definitions in
the referenced <tt>grammar</tt> pattern will be included in
<tt>grammar</tt> pattern containing the
<tt>include</tt> element.</p><p>The <tt>combine</tt> attribute is particularly useful
in conjunction with <tt>include</tt>.  For example, suppose
a RELAX NG pattern <tt>inline.rng</tt> provides a pattern
for inline content, which allows <tt>bold</tt> and
<tt>italic</tt> elements arbitrarily nested:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;define name="inline"&gt;
    &lt;zeroOrMore&gt;
      &lt;ref name="inline.class"/&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;define name="inline.class"&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="bold"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="italic"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>Another RELAX NG pattern could use <tt>inline.rng</tt>
and add <tt>code</tt> and <tt>em</tt> to the set
of inline elements as follows:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;include href="inline.rng"/&gt;

  &lt;start&gt;
    &lt;element name="doc"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="p"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="inline.class" combine="choice"&gt;
    &lt;choice&gt;
      &lt;element name="code"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
      &lt;element name="em"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;
  
&lt;/grammar&gt;</pre><p>This would be equivalent to</p><pre class="programlisting">&lt;grammar&gt;

  &lt;define name="inline"&gt;
    &lt;zeroOrMore&gt;
      &lt;ref name="inline.class"/&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;define name="inline.class"&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="bold"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="italic"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;

  &lt;start&gt;
    &lt;element name="doc"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="p"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="inline.class" combine="choice"&gt;
    &lt;choice&gt;
      &lt;element name="code"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
      &lt;element name="em"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;
  
&lt;/grammar&gt;</pre><p>which is equivalent to</p><pre class="programlisting">&lt;grammar&gt;

  &lt;define name="inline"&gt;
    &lt;zeroOrMore&gt;
      &lt;ref name="inline.class"/&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;define name="inline.class"&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="bold"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="italic"&gt;
	&lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="code"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
      &lt;element name="em"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;

  &lt;start&gt;
    &lt;element name="doc"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="p"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

&lt;/grammar&gt;</pre><p>Note that it is allowed for one of the definitions of a name to
omit the <tt>combine</tt> attribute.  However, it is an
error if there is more than one definition that does so.</p><p>The <tt>notAllowed</tt> pattern is useful when merging
grammars. The <tt>notAllowed</tt> pattern never matches
anything.  Just as adding <tt>empty</tt> to a
<tt>group</tt> makes no difference, so adding
<tt>notAllowed</tt> to a <tt>choice</tt> makes no
difference.  It is typically used to allow an including pattern to
specify additional choices with <tt>combine="choice"</tt>.
For example, if <tt>inline.rng</tt> were written like
this:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;define name="inline"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
	&lt;text/&gt;
	&lt;element name="bold"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
	&lt;element name="italic"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
	&lt;ref name="inline.extra"/&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;define name="inline.extra"&gt;
    &lt;notAllowed/&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>then it could be customized to allow inline
<tt>code</tt> and <tt>em</tt> elements as
follows:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;include href="inline.rng"/&gt;

  &lt;start&gt;
    &lt;element name="doc"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="p"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="inline.extra" combine="choice"&gt;
    &lt;choice&gt;
      &lt;element name="code"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
      &lt;element name="em"&gt;
	&lt;ref name="inline"&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;
  
&lt;/grammar&gt;</pre></div><div class="section"><a name="IDAVEZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDAVEZR"></a>9.4. Replacing definitions</h3></div></div><p>RELAX NG allows <tt>define</tt> elements to be put
inside the <tt>include</tt> element to indicate that they
are to replace definitions in the included <tt>grammar</tt>
pattern.</p><p>Suppose the file <tt>addressBook.rng</tt>
contains:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="cardContent"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="cardContent"&gt;
    &lt;element name="name"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
    &lt;element name="email"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>Suppose we wish to modify this pattern so that the
<tt>card</tt> element contains an
<tt>emailAddress</tt> element instead of an
<tt>email</tt> element. Then we could replace the definition
of <tt>cardContent</tt> as follows:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;include href="addressBook.rng"&gt;

    &lt;define name="cardContent"&gt;
      &lt;element name="name"&gt;
	&lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="emailAddress"&gt;
	&lt;text/&gt;
      &lt;/element&gt;
    &lt;/define&gt;

  &lt;/include&gt;

&lt;/grammar&gt;</pre><p>This would be equivalent to</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
	&lt;element name="card"&gt;
	  &lt;ref name="cardContent"/&gt;
	&lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="cardContent"&gt;
    &lt;element name="name"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
    &lt;element name="emailAddress"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>An <tt>include</tt> element can also contain a
<tt>start</tt> element, which replaces the
<tt>start</tt> in the included grammar pattern.</p></div></div><div class="section"><a name="IDADGZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDADGZR"></a>10. Namespaces</h2></div></div><p>RELAX NG is namespace-aware. Thus, it considers an element or attribute
to have both a local name and a namespace URI which together
constitute the name of that element or attribute.</p><div class="section"><a name="IDAIGZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDAIGZR"></a>10.1. Using the <tt>ns</tt> attribute</h3></div></div><p>The <tt>element</tt> pattern uses an <tt>ns</tt> attribute
to specify the namespace URI of the elements that it matches.  For
example,</p><pre class="programlisting">&lt;element name="foo" ns="http://www.example.com"&gt;
  &lt;empty/&gt;
&lt;/element&gt;</pre><p>would match any of:</p><pre class="programlisting">&lt;foo xmlns="http://www.example.com"/&gt;
&lt;e:foo xmlns:e="http://www.example.com"/&gt;
&lt;example:foo xmlns:example="http://www.example.com"/&gt;</pre><p>but not any of:</p><pre class="programlisting">&lt;foo/&gt;
&lt;e:foo xmlns:e="http://WWW.EXAMPLE.COM"/&gt;
&lt;example:foo xmlns:example="http://www.example.net"/&gt;</pre><p>A value of an empty string for the <tt>ns</tt> attribute
indicates a null or absent namespace URI (just as with the
<tt>xmlns</tt> attribute).  Thus, the pattern</p><pre class="programlisting">&lt;element name="foo" ns=""&gt;
  &lt;empty/&gt;
&lt;/element&gt;</pre><p>matches any of:</p><pre class="programlisting">&lt;foo xmlns=""/&gt;
&lt;foo/&gt;</pre><p>but not any of:</p><pre class="programlisting">&lt;foo xmlns="http://www.example.com"/&gt;
&lt;e:foo xmlns:e="http://www.example.com"/&gt;</pre><p>It is tedious and error-prone to specify the <tt>ns</tt>
attribute on every <tt>element</tt>, so RELAX NG allows it to be
defaulted.  If an <tt>element</tt> pattern does not specify an
<tt>ns</tt> attribute, then it defaults to the value of the
<tt>ns</tt> attribute of the nearest ancestor that has an
<tt>ns</tt> attribute, or the empty string if there is no such
ancestor. Thus,</p><pre class="programlisting">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;element name="addressBook" ns=""&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card" ns=""&gt;
      &lt;element name="name" ns=""&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email" ns=""&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>and</p><pre class="programlisting">&lt;element name="addressBook" ns="http://www.example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;element name="addressBook" ns="http://www.example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card" ns="http://www.example.com"&gt;
      &lt;element name="name" ns="http://www.example.com"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email" ns="http://www.example.com"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>The <tt>attribute</tt> pattern also takes an
<tt>ns</tt> attribute.  However, there is a
difference in how it defaults.  This is because of the fact that the
XML Namespaces Recommendation does not apply the default namespace to
attributes.  If an <tt>ns</tt> attribute is not
specified on the <tt>attribute</tt> pattern, then it
defaults to the empty string. Thus,</p><pre class="programlisting">&lt;element name="addressBook" ns="http://www.example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name"/&gt;
      &lt;attribute name="email"/&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;element name="addressBook" ns="http://www.example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card" ns="http://www.example.com"&gt;
      &lt;attribute name="name" ns=""/&gt;
      &lt;attribute name="email" ns=""/&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>and so will match</p><pre class="programlisting">&lt;addressBook xmlns="http://www.example.com"&gt;
  &lt;card name="John Smith" email="js@example.com"/&gt;
&lt;/addressBook&gt;</pre><p>or</p><pre class="programlisting">&lt;example:addressBook xmlns:example="http://www.example.com"&gt;
  &lt;example:card name="John Smith" email="js@example.com"/&gt;
&lt;/example:addressBook&gt;</pre><p>but not</p><pre class="programlisting">&lt;example:addressBook xmlns:example="http://www.example.com"&gt;
  &lt;example:card example:name="John Smith" example:email="js@example.com"/&gt;
&lt;/example:addressBook&gt;</pre></div><div class="section"><a name="IDAYJZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDAYJZR"></a>10.2. Qualified names</h3></div></div><p>When a pattern matches elements and attributes from multiple
namespaces, using the <tt>ns</tt> attribute would require
repeating namespace URIs in different places in the pattern.  This is
error-prone and hard to maintain, so RELAX NG also allows the
<tt>element</tt> and <tt>attribute</tt> patterns to use a
prefix in the value of the <tt>name</tt> attribute to specify the
namespace URI. In this case, the prefix specifies the namespace URI to
which that prefix is bound by the namespace declarations in scope on
the <tt>element</tt> or <tt>attribute</tt> pattern. Thus,</p><pre class="programlisting">&lt;element name="ab:addressBook" xmlns:ab="http://www.example.com/addressBook"
                               xmlns:a="http://www.example.com/address"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="ab:card"&gt;
      &lt;element name="a:name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="a:email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>is equivalent to</p><pre class="programlisting">&lt;element name="addressBook" ns="http://www.example.com/addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card" ns="http://www.example.com/addressBook"&gt;
      &lt;element name="name" ns="http://www.example.com/address"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email" ns="http://www.example.com/address"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>If a prefix is specified in the value of the <tt>name</tt>
attribute of an <tt>element</tt> or <tt>attribute</tt>
pattern, then that prefix determines the namespace URI of the elements
or attributes that will be matched by that pattern, regardless of
the value of any <tt>ns</tt> attribute.</p><p>Note that the XML default namespace (as specified by the
<tt>xmlns</tt> attribute) is not used in determining the namespace
URI of elements and attributes that <tt>element</tt> and
<tt>attribute</tt> patterns match.</p></div></div><div class="section"><a name="IDAFLZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAFLZR"></a>11. Name classes</h2></div></div><p>Normally, the name of the element to be matched by an
<tt>element</tt> element is specified by a <tt>name</tt>
attribute.  An <tt>element</tt> element can instead start with an
element specifying a <i>name-class</i>.  In this case, the
<tt>element</tt> pattern will only match an element if the name of
the element is a member of the name-class.  The simplest name-class is
<tt>anyName</tt>, which any name at all is a member of, regardless
of its local name and its namespace URI.  For example, the following
pattern matches any well-formed XML document:</p><pre class="programlisting">&lt;grammar&gt;

  &lt;start&gt;
    &lt;ref name="anyElement"/&gt;
  &lt;/start&gt;

  &lt;define name="anyElement"&gt;
    &lt;element&gt;
      &lt;anyName/&gt;
      &lt;zeroOrMore&gt;
	&lt;choice&gt;
	  &lt;attribute&gt;
	    &lt;anyName/&gt;
	  &lt;/attribute&gt;
	  &lt;text/&gt;
	  &lt;ref name="anyElement"/&gt;
	&lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</pre><p>The <tt>nsName</tt> name-class contains any
name with the namespace URI specified by the
<tt>ns</tt> attribute, which defaults in the same way
as the <tt>ns</tt> attribute on the
<tt>element</tt> pattern.</p><p>The <tt>choice</tt> name-class matches any name that is a
member of any of its child name-classes.</p><p>The <tt>anyName</tt> and <tt>nsName</tt>
name-classes can contain an <tt>except</tt> clause. For
example,</p><pre class="programlisting">&lt;element name="card" ns="http://www.example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;attribute&gt;
      &lt;anyName&gt;
        &lt;except&gt;
          &lt;nsName/&gt;
          &lt;nsName ns=""/&gt;
        &lt;/except&gt;
      &lt;/anyName&gt;
    &lt;/attribute&gt;
  &lt;/zeroOrMore&gt;
  &lt;text/&gt;
&lt;/element&gt;</pre><p>would allow the <tt>card</tt> element to have any number of
namespace-qualified attributes provided that they were qualified with
namespace other than that of the <tt>card</tt> element.</p><p>Note that an <tt>attribute</tt> pattern matches a single
attribute even if it has a name-class that contains multiple names.
To match zero or more attributes, the <tt>zeroOrMore</tt> element
must be used.</p><p>The <tt>name</tt> name-class contains a single name.
The content of the <tt>name</tt> element specifies the name
in the same way as the <tt>name</tt> attribute of the
<tt>element</tt> pattern.  The <tt>ns</tt>
attribute specifies the namespace URI in the same way as the
<tt>element</tt> pattern.</p><p>Some schema languages have a concept of <i>lax</i> validation,
where an element or attribute is validated against a definition only
if there is one.  We can implement this concept in RELAX NG with name
classes that uses <tt>except</tt> and <tt>name</tt>.
Suppose, for example, we wanted to allow an element to have any
attribute with a qualified name, but we still wanted to ensure that if
there was an <tt>xml:space</tt> attribute, it had the value
<tt>default</tt> or <tt>preserve</tt>.  It wouldn't work to
use</p><pre class="programlisting">&lt;element name="example"&gt;
  &lt;zeroOrMore&gt;
    &lt;attribute&gt;
      &lt;anyName/&gt;
    &lt;/attribute&gt;
  &lt;/zeroOrMore&gt;
  &lt;optional&gt;
    &lt;attribute name="xml:space"&gt;
      &lt;choice&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;preserve&lt;/value&gt;
      &lt;/choice&gt;
    &lt;/attribute&gt;
  &lt;/optional&gt;
&lt;/element&gt;</pre><p>because an <tt>xml:space</tt> attribute with a value
other than <tt>default</tt> or <tt>preserve</tt>
would match</p><pre class="programlisting">    &lt;attribute&gt;
      &lt;anyName/&gt;
    &lt;/attribute&gt;</pre><p>even though it did not match</p><pre class="programlisting">    &lt;attribute name="xml:space"&gt;
      &lt;choice&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;preserve&lt;/value&gt;
      &lt;/choice&gt;
    &lt;/attribute&gt;</pre><p>The solution is to use <tt>name</tt> together with
<tt>except</tt>:</p><pre class="programlisting">&lt;element name="example"&gt;
  &lt;zeroOrMore&gt;
    &lt;attribute&gt;
      &lt;anyName&gt;
        &lt;except&gt;
          &lt;name&gt;xml:space&lt;/name&gt;
        &lt;/except&gt;
      &lt;/anyName&gt;
    &lt;/attribute&gt;
  &lt;/zeroOrMore&gt;
  &lt;optional&gt;
    &lt;attribute name="xml:space"&gt;
      &lt;choice&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;preserve&lt;/value&gt;
      &lt;/choice&gt;
    &lt;/attribute&gt;
  &lt;/optional&gt;
&lt;/element&gt;</pre><p>Note that the <tt>define</tt> element cannot contain a
name-class; it can only contain a pattern.</p></div><div class="section"><a name="IDA1OZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA1OZR"></a>12. Annotations</h2></div></div><p>If a RELAX NG element has an attribute or child element with a
namespace URI other than the RELAX NG namespace, then that attribute or
element is ignored.  Thus, you can add annotations to RELAX NG patterns
simply by using an attribute or element in a separate namespace:</p><pre class="programlisting">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0" xmlns:a="http://www.example.com/annotation"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;a:documentation&gt;Information about a single email address.&lt;/a:documentation&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre><p>RELAX NG also provides a <tt>div</tt> element which
allows an annotation to be applied to a group of definitions in a
grammar.  For example, you might want to divide up the definitions of
the grammar into modules:</p><pre class="programlisting">&lt;grammar xmlns:m="http://www.example.com/module"&gt;

  &lt;div m:name="inline"&gt;

    &lt;define name="code"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;
    &lt;define name="em"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;
    &lt;define name="var"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;

  &lt;/div&gt;

  &lt;div m:name="block"&gt;

    &lt;define name="p"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;
    &lt;define name="ul"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;
    &lt;define name="ol"&gt; <i><tt>pattern</tt></i> &lt;/define&gt;

  &lt;/div&gt;

&lt;/grammar&gt;</pre><p>This would allow you easily to generate variants of the grammar
based on a selection of modules.</p><p>A companion specification, RELAX NG DTD Compatibility
<a href="#compat" title="[Compatibility]">[Compatibility]</a>, defines annotations to implement
some features of XML DTDs.</p></div><div class="section"><a name="IDA3PZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA3PZR"></a>13. Nested grammars</h2></div></div><p>There is no prohibition against nesting grammar patterns.  A
<tt>ref</tt> pattern refers to a definition from nearest
<tt>grammar</tt> ancestor. There is also a
<tt>parentRef</tt> element that escapes out of the current
grammar and references a definition from the parent of the current
grammar.</p><p>Imagine the problem of writing a pattern for tables.  The pattern
for tables only cares about the structure of tables; it doesn't care
about what goes inside a table cell.  First, we create a RELAX NG pattern
<tt>table.rng</tt> as follows:</p><pre class="programlisting">&lt;grammar&gt;

&lt;define name="cell.content"&gt;
  &lt;notAllowed/&gt;
&lt;/define&gt;

&lt;start&gt;
  &lt;element name="table"&gt;
    &lt;oneOrMore&gt;
      &lt;element name="tr"&gt;
        &lt;oneOrMore&gt;
	  &lt;element name="td"&gt;
	    &lt;ref name="cell.content"/&gt;
	  &lt;/element&gt;
        &lt;/oneOrMore&gt;
      &lt;/element&gt;
    &lt;/oneOrMore&gt;
  &lt;/element&gt;
&lt;/start&gt;

&lt;/grammar&gt;</pre><p>Patterns that include <tt>table.rng</tt> must redefine
<tt>cell.content</tt>. By using a nested
<tt>grammar</tt> pattern containing a
<tt>parentRef</tt> pattern, the including pattern can
redefine <tt>cell.content</tt> to be a pattern defined in
the including pattern's grammar, thus effectively importing a pattern
from the parent grammar into the child grammar:</p><pre class="programlisting">&lt;grammar&gt;

&lt;start&gt;
  &lt;element name="doc"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
	&lt;element name="p"&gt;
	  &lt;ref name="inline"/&gt;
	&lt;/element&gt;
	&lt;grammar&gt;
	  &lt;include href="table.rng"&gt;
	    &lt;define name="cell.content"&gt;
	      &lt;parentRef name="inline"/&gt;
	    &lt;/define&gt;
          &lt;/include&gt;
	&lt;/grammar&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/element&gt;
&lt;/start&gt;

&lt;define name="inline"&gt;
  &lt;zeroOrMore&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="em"&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;

&lt;/grammar&gt;</pre><p>Of course, in a trivial case like this, there is no advantage in
nesting the grammars: we could simply have included
<tt>table.rng</tt> within the outer <tt>grammar</tt> element.
However, when the included grammar has many definitions, nesting it
avoids the possibility of name conflicts between the including grammar
and the included grammar.</p></div><div class="section"><a name="IDAIRZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDAIRZR"></a>14. Non-restrictions</h2></div></div><p>RELAX NG does not require patterns to be "deterministic" or
"unambiguous".</p><p>Suppose we wanted to write the email address book in HTML, but use
class attributes to specify the structure:</p><pre class="programlisting">&lt;element name="html"&gt;
  &lt;element name="head"&gt;
    &lt;element name="title"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/element&gt;
  &lt;element name="body"&gt;
    &lt;element name="table"&gt;
      &lt;attribute name="class"&gt;
        &lt;value&gt;addressBook&lt;/value&gt;
      &lt;/attribute&gt;
      &lt;oneOrMore&gt;
        &lt;element name="tr"&gt;
	  &lt;attribute name="class"&gt;
	    &lt;value&gt;card&lt;/value&gt;
	  &lt;/attribute&gt;
          &lt;element name="td"&gt;
	    &lt;attribute name="class"&gt;
	      &lt;value&gt;name&lt;/value&gt;
	    &lt;/attribute&gt;
            &lt;interleave&gt;
              &lt;text/&gt;
              &lt;optional&gt;
                &lt;element name="span"&gt;
                  &lt;attribute name="class"&gt;
                    &lt;value&gt;givenName&lt;/value&gt;
                  &lt;/attribute&gt;
                  &lt;text/&gt;
                &lt;/element&gt;
              &lt;/optional&gt;
              &lt;optional&gt;
                &lt;element name="span"&gt;
                  &lt;attribute name="class"&gt;
                    &lt;value&gt;familyName&lt;/value&gt;
                  &lt;/attribute&gt;
                  &lt;text/&gt;
                &lt;/element&gt;
              &lt;/optional&gt;
            &lt;/interleave&gt;
          &lt;/element&gt;
          &lt;element name="td"&gt;
	    &lt;attribute name="class"&gt;
	      &lt;value&gt;email&lt;/value&gt;
	    &lt;/attribute&gt;
            &lt;text/&gt;
          &lt;/element&gt;
        &lt;/element&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/element&gt;
&lt;/element&gt;</pre><p>This would match a XML document such as:</p><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Example Address Book&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table class="addressBook"&gt;
      &lt;tr class="card"&gt;
        &lt;td class="name"&gt;
          &lt;span class="givenName"&gt;John&lt;/span&gt;
          &lt;span class="familyName"&gt;Smith&lt;/span&gt;
        &lt;/td&gt;
        &lt;td class="email"&gt;js@example.com&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>but not:</p><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Example Address Book&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table class="addressBook"&gt;
      &lt;tr class="card"&gt;
        &lt;td class="name"&gt;
          &lt;span class="givenName"&gt;John&lt;/span&gt;
          &lt;!-- Note the incorrect class attribute --&gt;
          &lt;span class="givenName"&gt;Smith&lt;/span&gt;
        &lt;/td&gt;
        &lt;td class="email"&gt;js@example.com&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><div class="section"><a name="IDA3RZR"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="IDA3RZR"></a>15. Further information</h2></div></div><p>The definitive specification of RELAX NG is <a href="#spec" title="[RELAX NG]">[RELAX NG]</a>.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="IDAGSZR"></a>A. Comparison with XML DTDs</h2><p>RELAX NG provides functionality that goes beyond XML DTDs. In
particular, RELAX NG</p><div class="itemizedlist"><ul><li><a name="IDAMSZR"></a>uses XML syntax to represent schemas</li><li><a name="IDAPSZR"></a>supports datatyping</li><li><a name="IDASSZR"></a>integrates attributes into content
models</li><li><a name="IDAVSZR"></a>supports XML namespaces</li><li><a name="IDAYSZR"></a>supports unordered content</li><li><a name="IDA1SZR"></a>supports context-sensitive content
models</li></ul></div><p>ID/IDREF validation is not provided by RELAX NG; however, it is
provided by a companion specification, RELAX NG DTD Compatibility
<a href="#compat" title="[Compatibility]">[Compatibility]</a>.  Comprehensive support for
cross-reference checking is planned for a future specification.</p><p>RELAX NG does not support features of XML DTDs that involve
changing the infoset of an XML document.  In particular, RELAX
NG</p><div class="itemizedlist"><ul><li><a name="IDAHTZR"></a>does not allow defaults for attributes to be
specified; however, this is allowed by RELAX NG DTD Compatibility
<a href="#compat" title="[Compatibility]">[Compatibility]</a></li><li><a name="IDAMTZR"></a>does not allow entities to be specified</li><li><a name="IDAPTZR"></a>does not allow notations to be specified</li><li><a name="IDASTZR"></a>does not specify whether whitespace is significant</li></ul></div><p>Also RELAX NG does not define a way for an XML document to associate
itself with a RELAX NG pattern.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="IDAZTZR"></a>B. Comparison with RELAX Core</h2><p>Any description in RELAX Core can be directly captured in RELAX
NG without loss of information.</p><div class="section"><a name="IDA4TZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDA4TZR"></a>B.1. Mapping RELAX NG to RELAX Core</h3></div></div><div class="section"><a name="IDABUZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDABUZR"></a>B.1.1. <tt>elementRule</tt>-<tt>tag</tt> pairs</h4></div></div><p>An <tt>elementRule</tt> as well as the referenced
<tt>tag</tt> element is typically captured by a
<tt>define</tt> element containing an
<tt>element</tt> element as the child.</p><p>An <tt>elementRule</tt>-<tt>tag</tt> pair 
in RELAX Core is shown below:</p><pre class="programlisting">
&lt;elementRule role="foo" label="bar"&gt;
  <i><tt>hedge model</tt></i>
&lt;/elementRule&gt;
</pre><pre class="programlisting">
&lt;tag role="foo" name="baz"&gt;
  <i><tt>attribute declarations</tt></i>
&lt;/tag&gt;
</pre><p>A rewrite in RELAX NG is shown below:</p><pre class="programlisting">
&lt;define name="bar"&gt;
  &lt;element name="baz"&gt;
    <i><tt>hedge model</tt></i>
    <i><tt>attribute declarations</tt></i>
  &lt;/element&gt;
&lt;/define&gt;
</pre></div><div class="section"><a name="IDAJVZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDAJVZR"></a>B.1.2. <tt>hedgeRule</tt></h4></div></div><p>A <tt>hedgeRule</tt> element is captured by a
<tt>define</tt> element containing attribute
declarations.</p><p>A <tt>hedgeRule</tt> element
in RELAX Core is shown below:</p><pre class="programlisting">
&lt;hedgeRule label="bar"&gt;
  <i><tt>hedge model</tt></i>
&lt;/hedgeRule&gt;
</pre><p>A rewrite in RELAX NG is:</p><pre class="programlisting">
&lt;define name="bar"&gt;
  <i><tt>hedge model</tt></i>
&lt;/define&gt;
</pre></div><div class="section"><a name="IDACWZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDACWZR"></a>B.1.3. <tt>attPool</tt></h4></div></div><p>An <tt>attPool</tt> element
in RELAX Core is shown below:</p><pre class="programlisting">
&lt;attPool role="foo"&gt;
  <i><tt>attribute declarations</tt></i>
&lt;/attPool&gt;
</pre><p>A rewrite in RELAX NG is</p><pre class="programlisting">
&lt;define name="foo"&gt;
  <i><tt>attribute declarations</tt></i>
&lt;/define&gt;
</pre></div><div class="section"><a name="IDAVWZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDAVWZR"></a>B.1.4. Hedge models</h4></div></div><p>Mapping of hedge models in RELAX Core to RELAX NG is summarized below:
</p><div class="orderedlist"><ol type="1"><li><a name="IDA1WZR"></a>
<tt>occurs="*"</tt> in RELAX Core 
is captured by
<tt>&lt;zeroOrMore&gt;...&lt;/zeroOrMore&gt;</tt>.
</li><li><a name="IDACXZR"></a>
<tt>occurs="+"</tt> in RELAX Core 
is captured by
<tt>&lt;oneOrMore&gt;...&lt;/oneOrMore&gt;</tt>
</li><li><a name="IDAJXZR"></a>
<tt>occurs="?"</tt> in RELAX Core 
is captured by
<tt>&lt;optional&gt;...&lt;/optional&gt;</tt>
</li><li><a name="IDAQXZR"></a>
<tt>&lt;mixed&gt;...&lt;/mixed&gt;</tt> in
RELAX Core is captured by
<tt>&lt;mixed&gt;...&lt;/mixed&gt;</tt>
</li><li><a name="IDAXXZR"></a>
<tt>&lt;ref label="..."/&gt;</tt> in
RELAX Core is captured by
<tt>&lt;ref name="..."/&gt;</tt>.
</li><li><a name="IDA4XZR"></a>
<tt>&lt;hedgeRef label="..."/&gt;</tt> in
RELAX Core is captured by
<tt>&lt;ref name="..."/&gt;</tt>
</li></ol></div></div><div class="section"><a name="IDAKYZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDAKYZR"></a>B.1.5. Attribute declarations</h4></div></div><p>Both languages use <tt>attribute</tt>.  However, in
RELAX Core, an <tt>attribute</tt> without
<tt>required="true"</tt> declares a defaultable attribute.  
On the other hand, in RELAX NG, a defaultable attribute has to 
be declared by an <tt>attribute</tt> element within 
an <tt>optional</tt> element.</p><p>Declaration of a required attribute in RELAX Core is shown below:</p><pre class="programlisting">
&lt;attribute name="foo" type="integer" required="true"/&gt;
</pre><p>In RELAX NG, this is captured by:</p><pre class="programlisting">
&lt;attribute name="foo"&gt;
  &lt;data type="integer"/&gt;
&lt;/attribute&gt;
</pre><p>Declaration of an optional attribute in RELAX Core is shown
below:</p><pre class="programlisting">
&lt;attribute name="foo" type="integer"/&gt;
</pre><p>In RELAX NG, this is captured by:</p><pre class="programlisting">
&lt;optional&gt;
  &lt;attribute name="foo"&gt;
    &lt;data type="integer"/&gt;
  &lt;/attribute&gt;
&lt;/optional&gt;
</pre></div></div><div class="section"><a name="IDALZZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDALZZR"></a>B.2. Examples</h3></div></div><div class="section"><a name="IDAOZZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDAOZZR"></a>B.2.1. Ancestor-and-sibling-sensitive content models</h4></div></div><p>Here is a rewrite of an example in <a href="http://www.xml.gr.jp/relax/html4/howToRELAX_p1_c8_en.html" target="_top">STEP
7</a> of "HOW TO RELAX".  The first paragraph cannot contain
footnotes, but the other paragraphs can.</p><pre class="programlisting">
&lt;grammar&gt;
  &lt;start&gt;
    &lt;element name="doc"&gt;
      &lt;ref name="paraWithoutFNotes"/&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="paraWithFNotes"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="paraWithoutFNotes"&gt;
    &lt;element name="para"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="paraWithFNotes"&gt;
    &lt;element name="para"&gt;
      &lt;mixed&gt;
        &lt;zeroOrMore&gt;
          &lt;element name="fnote"&gt;
            &lt;text/&gt;
          &lt;/element&gt;
        &lt;/zeroOrMore&gt;
      &lt;/mixed&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;
</pre><p>The following document matches this pattern:</p><pre class="programlisting">
&lt;doc&gt;&lt;para/&gt;&lt;para&gt;&lt;fnote/&gt;&lt;/para&gt;&lt;/doc&gt;
</pre><p>On the other hand, the following document does not:</p><pre class="programlisting">
&lt;doc&gt;&lt;para&gt;&lt;fnote/&gt;&lt;/para&gt;&lt;/doc&gt;
</pre></div><div class="section"><a name="IDAC0ZR"></a><div class="titlepage"><div><h4 class="title"><a name="IDAC0ZR"></a>B.2.2. Attribute-sensitive content model</h4></div></div><p>Here is a rewrite of an example in <a href="http://www.xml.gr.jp/relax/html4/howToRELAX_p1_c9_en.html" target="_top">STEP
8</a> of "HOW TO RELAX".  This pattern assigns different content
models for the same tag name <tt>div</tt> depending on the
value of the attribute <tt>class</tt>.</p><pre class="programlisting">
&lt;grammar&gt;

  &lt;start&gt;
    &lt;element name="html"&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="section"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="section"&gt;
    &lt;element name="div"&gt;
      &lt;attribute name="class"&gt;&lt;value&gt;section&lt;/value&gt;&lt;/attribute&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="para"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="subsection"/&gt;
      &lt;/zeroOrMore&gt;
   &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="subsection"&gt;
    &lt;element name="div"&gt;
      &lt;attribute name="class"&gt;&lt;value&gt;subsection&lt;/value&gt;&lt;/attribute&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="para"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;
</pre><p>The following document matches this pattern:</p><pre class="programlisting">
&lt;html&gt;
  &lt;div class="section"&gt;
    &lt;para/&gt;
    &lt;div class="subsection"&gt;
      &lt;para/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="section"&gt;
    &lt;div class="subsection"&gt;
      &lt;para/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/html&gt;
</pre><p>On the other hand, the following document does not:</p><pre class="programlisting">
&lt;html&gt;
  &lt;div class="subsection"&gt;
    &lt;para/&gt;
    &lt;div class="section"&gt;
      &lt;para/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/html&gt;
</pre></div></div><div class="section"><a name="IDA10ZR"></a><div class="titlepage"><div><h3 class="title"><a name="IDA10ZR"></a>B.3. Features of RELAX NG beyond RELAX Core</h3></div></div><p>RELAX NG has some features which are missing in RELAX
Core.</p><div class="orderedlist"><ol type="1"><li><a name="IDAB1ZR"></a>Namespaces: since RELAX Core is intended to be used in
conjunction with RELAX Namespace, RELAX Core does not support
namespaces.  On the other hand, RELAX NG supports namespaces.  RELAX
Namespace will be extended so that it can work with RELAX NG.
</li><li><a name="IDAE1ZR"></a>Mixture of <tt>element</tt> and
<tt>attribute</tt>: RELAX Core does not allow their 
mixture but rather provide two types of basic constructs, 
namely <tt>elementRule/hedgeRule</tt> and 
<tt>tag/attPool</tt>.</li><li><a name="IDAP1ZR"></a>Name classes: RELAX Core does not have name
classes but merely provide name literals.</li><li><a name="IDAS1ZR"></a><tt>interleave</tt>:  RELAX Core does not 
provide any mechanism for interleaving.</li><li><a name="IDAX1ZR"></a>Datatype libraries: RELAX Core allows XML Schema Part
2 but does not allow other datatype libaries.</li><li><a name="IDA01ZR"></a><tt>define</tt> in <tt>include</tt>: 
RELAX Core does not allow such redefinitions.</li><li><a name="IDAB2ZR"></a><tt>list</tt>: RELAX Core does not provide
such structured strings.</li><li><a name="IDAG2ZR"></a><tt>data</tt> in <tt>choice</tt>:
in RELAX Core, the hedge model of <tt>elementRule</tt> is 
either a datatype reference or an expression without datatype 
references.</li></ol></div></div></div><div class="appendix"><h2 class="title" style="clear: both"><a name="IDAS2ZR"></a>C. Comparison with TREX</h2><p>RELAX NG has the following changes from TREX:</p><div class="orderedlist"><ol type="1"><li><a name="IDAY2ZR"></a>the <tt>concur</tt> pattern has been removed</li><li><a name="IDA32ZR"></a>the <tt>string</tt> pattern has been replaced by the
<tt>value</tt> pattern</li><li><a name="IDAE3ZR"></a>the <tt>anyString</tt> pattern has been renamed to
<tt>text</tt></li><li><a name="IDAK3ZR"></a>the namespace URI is different</li><li><a name="IDAN3ZR"></a>pattern elements must be namespace qualified</li><li><a name="IDAQ3ZR"></a>anonymous datatypes have been removed</li><li><a name="IDAT3ZR"></a>the <tt>data</tt> pattern can have parameters specified by
<tt>param</tt> child elements</li><li><a name="IDA03ZR"></a>the <tt>list</tt> pattern has been added
for matching whitespace-separated lists of tokens</li><li><a name="IDA53ZR"></a>the <tt>replace</tt> and
<tt>group</tt> values for the <tt>combine</tt>
attribute have been removed</li><li><a name="IDAI4ZR"></a>an <tt>include</tt> element in a grammar may contain
<tt>define</tt> elements that replace included definitions</li><li><a name="IDAP4ZR"></a>the restriction that definitions combined with the
<tt>combine</tt> attribute must be from different files has
been removed</li><li><a name="IDAU4ZR"></a>a <tt>div</tt> element may be used to group
together definitions within a
<tt>grammar</tt></li><li><a name="IDA04ZR"></a>an <tt>include</tt> element occurring as a
pattern has been renamed to <tt>externalRef</tt>; an
<tt>include</tt> element is now allowed only as a child of
the <tt>grammar</tt> element</li><li><a name="IDAF5ZR"></a>the <tt>parent</tt> attribute on the
<tt>ref</tt> element has been replaced by a new
<tt>parentRef</tt> element</li><li><a name="IDAO5ZR"></a>the <tt>type</tt> attribute of the
<tt>data</tt> element is an unqualified name; the
<tt>data</tt> element uses the
<tt>datatypeLibrary</tt> attribute rather than the
<tt>ns</tt> attribute to identify the namespace of the
datatype</li><li><a name="IDA15ZR"></a>a <tt>start</tt> element is not allowed to
have a <tt>name</tt> attribute</li><li><a name="IDAFA0R"></a>an <tt>attribute</tt> element is not allowed
to have a <tt>global</tt> attribute</li><li><a name="IDAMA0R"></a>the <tt>not</tt> and <tt>difference</tt>
name classes have been replaced by <tt>except</tt></li><li><a name="IDAUA0R"></a>the <tt>data</tt> element may have
an <tt>except</tt> child</li></ol></div></div><div class="appendix"><h2 class="title" style="clear: both"><a name="IDA3A0R"></a>D. Changes from 12 June 2001 version</h2><div class="orderedlist"><ol type="1"><li><a name="IDABB0R"></a><tt>key</tt> and <tt>keyRef</tt>
have been removed; support for ID and IDREF is now available
in a companion specification, RELAX NG DTD Compatibility
Annotations <a href="#compat" title="[Compatibility]">[Compatibility]</a></li><li><a name="IDAKB0R"></a><tt>difference</tt> and <tt>not</tt>
have been replaced by <tt>except</tt></li><li><a name="IDASB0R"></a>a <tt>start</tt> element is no longer
allowed to have a <tt>name</tt> attribute</li><li><a name="IDAZB0R"></a>an <tt>attribute</tt> element is no longer
allowed to have a <tt>global</tt>
attribute</li></ol></div></div><div id="IDACC0R" class="bibliography"><div class="titlepage"><div><h2 class="title"><a name="IDACC0R"></a>References</h2></div></div><dl><dt>Compatibility</dt><dd id="compat" class="bibliomixed"><a name="compat"></a>James Clark, Makoto
MURATA, editors.  <span class="citetitle"><i><a href="http://www.oasis-open.org/committees/relax-ng/compatibility.html" target="_top">RELAX NG
DTD Compatibility</a></i></span>.  OASIS, 2001.</dd><dt>RELAX</dt><dd id="relax" class="bibliomixed"><a name="relax"></a>MURATA Makoto.
<span class="citetitle"><i><a href="http://www.xml.gr.jp/relax/" target="_top">RELAX (Regular
Language description for XML)</a></i></span>.  INSTAC
(Information Technology Research and Standardization Center), 2001.</dd><dt>RELAX NG</dt><dd id="spec" class="bibliomixed"><a name="spec"></a>James Clark, Makoto
MURATA, editors.  <span class="citetitle"><i><a href="http://www.oasis-open.org/committees/relax-ng/spec.html" target="_top">RELAX NG
Specification</a></i></span>.  OASIS, 2001.</dd><dt>TREX</dt><dd id="trex" class="bibliomixed"><a name="trex"></a>James Clark.
<span class="citetitle"><i><a href="http://www.thaiopensource.com/trex/" target="_top">TREX - Tree Regular Expressions for XML</a></i></span>.
Thai Open Source Software Center, 2001.</dd><dt>W3C XML Schema Datatypes</dt><dd id="xmlschema-2" class="bibliomixed"><a name="xmlschema-2"></a>Paul V. Biron, Ashok Malhotra, editors.
<span class="citetitle"><i><a href="http://www.w3.org/TR/xmlschema-2/" target="_top">XML Schema Part 2: Datatypes</a></i></span>.
W3C (World Wide Web Consortium), 2001.</dd></dl></div></div></body></html>